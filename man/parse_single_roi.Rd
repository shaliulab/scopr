% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parse-single-roi.R
\name{parse_single_roi}
\alias{parse_single_roi}
\title{Load data from a SQLite database for one ROI and preanalyze it
We obtain data from one ROI and optionaly preanalyse it, by applying FUN.
This function is run on single individual data
The actual work is done by parse_single_roi_wrapped. This function just does the following things before calling parse_single_roi_wrapped:
\itemize{
\item{Figure out which columns need to be queried from the SQLite file}
\item{Report information messages if the user wants to}
\item{Set up a memoised cache}
\item{Confirm the passed input leads to a sqlite file (the file ends in db) and check its size. The size is used later on to check whether the cache is invalid or not}
}
Very importantly, after calling parse_single_roi_wrapped, the passed metadata input is bound to the loaded data into a behavr table}
\usage{
parse_single_roi(
  data,
  min_time = 0,
  max_time = +Inf,
  reference_hour = NULL,
  columns = NULL,
  cache = NULL,
  verbose = FALSE,
  FUN = NULL,
  callback = NULL,
  ...
)
}
\arguments{
\item{data}{one row data.table corresponding to a row of the original (and then linked) metadata}

\item{min_time}{numeric, time in seconds from the start of the experiment after which the data is loaded into R}

\item{max_time}{numeric, time in seconds from the start of the experiment after which the data is not loaded into R}

\item{reference_hour}{integer, hour of the day in GMT TZ when the incubator turned the light on. If the reference hour did not happen yet on the loading day,
a whole extra day is prepended to the data, because the time series always starts with an L phase (even if this L phase is fully NA)}

\item{columns}{Columns to be loaded from the dbfile. Checked against the VAR_MAP for availability}

\item{cache}{character, path to a folder in the filesystem where cache files should be saved or searched to speed up future reloads of the same data}

\item{verbose}{boolean, if TRUE, all information messages are printed on the console. The loading process is silent otherwise}

\item{FUN}{A function or list of functions}

\item{callback}{Function to call when a new animal is loaded successfully from the SQLite database}

\item{...}{Additional arguments to FUN}
}
\value{
A behavr table containing the loaded and pre analyzed data
}
\description{
Load data from a SQLite database for one ROI and preanalyze it
We obtain data from one ROI and optionaly preanalyse it, by applying FUN.
This function is run on single individual data
The actual work is done by parse_single_roi_wrapped. This function just does the following things before calling parse_single_roi_wrapped:
\itemize{
\item{Figure out which columns need to be queried from the SQLite file}
\item{Report information messages if the user wants to}
\item{Set up a memoised cache}
\item{Confirm the passed input leads to a sqlite file (the file ends in db) and check its size. The size is used later on to check whether the cache is invalid or not}
}
Very importantly, after calling parse_single_roi_wrapped, the passed metadata input is bound to the loaded data into a behavr table
}
\seealso{
\url{https://github.com/shaliulab/behavr}
}
